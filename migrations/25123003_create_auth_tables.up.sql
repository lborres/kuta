-- Migration: create auth tables using app-generated NanoID (text ID)
-- This migration uses `public.nanoid` domain (text) and enforces a NanoID-like format
-- (22 URL-safe characters). IDs are expected to be generated by the application
-- using the NanoID implementation (e.g. internal/crypto.NewNanoID()).

BEGIN;

SELECT pg_advisory_xact_lock(25123003);

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'nanoid') THEN
    CREATE DOMAIN public.nanoid AS text
      CHECK (char_length(VALUE) = 22 AND VALUE ~ '^[A-Za-z0-9_-]+$');
  END IF;
END$$;

-- Users table (identity)
CREATE TABLE IF NOT EXISTS public.users (
  id public.nanoid PRIMARY KEY DEFAULT gen_random_nanoid(),
  email text NOT NULL UNIQUE,
  email_verified boolean NOT NULL DEFAULT false,
  name text NOT NULL,
  image text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Accounts table (credentials)
CREATE TABLE IF NOT EXISTS public.accounts (
  id public.nanoid PRIMARY KEY DEFAULT gen_random_nanoid(),
  user_id text NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  provider_id text NOT NULL,
  account_id text NOT NULL,
  password text,
  access_token text,
  refresh_token text,
  expires_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(provider_id, account_id)
);

-- Sessions table (active login sessions)
CREATE TABLE IF NOT EXISTS public.sessions (
  id public.nanoid PRIMARY KEY DEFAULT gen_random_nanoid(),
  user_id text NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  token_hash text NOT NULL UNIQUE,
  ip_address text,
  user_agent text,
  expires_at timestamptz NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Indexes for lookups
CREATE INDEX IF NOT EXISTS idx_accounts_user_id ON public.accounts(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON public.sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON public.users(email);

DO $$
BEGIN
  INSERT INTO public.__migrations (migration_name, applied_at)
  VALUES ('25123003_create_auth_tables.up.sql', now())
  ON CONFLICT (migration_name) DO UPDATE SET applied_at = EXCLUDED.applied_at;
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'Failed to record migration in public.__migrations: %', SQLERRM;
END$$;

COMMIT;
